#!/bin/ksh

set -eu

usage() {
	cat <<-EOF | xargs 1>&2
	usage: robsd
	[-D]
	[-c file]
	[-r path]
	[-S src-diff]
	[-X xenocara-diff]
	EOF
	exit 1
}

atexit() {
	local _err=$?

	lock_release "$BUILDDIR"

	if [ $_err -ne 0 ] || must_report "$STEP"; then
		report -r "${LOGDIR}/report" -s "${LOGDIR}/steps"
		# Do not send mail during interactive invocations.
		if [ "$DETACH" -eq 1 ]; then
			sendmail root <"${LOGDIR}/report"
		fi
	fi

	if [ $_err -ne 0 ]; then
		info "failed in step ${STEP:-unknown}"
	fi

	return "$_err"
}

main() {
	local _exit _log _t0 _t1

	while :; do
		STEP="$(step_resolve "$S")"
		info "step ${STEP}"

		if [ "$STEP" = "end" ]; then
			# The duration of the end step is the accumulated
			# duration.
			step_end -d "$(duration_total "${LOGDIR}/steps")" \
				-n "$STEP" -s "$S" "${LOGDIR}/steps"
			return 0
		fi

		_log="${LOGDIR}/$(log_id -l "$LOGDIR" -n "$STEP" -s "$S")"
		_exit=0
		_t0="$(date '+%s')"
		step_begin -l "$_log" -n "$STEP" -s "$S" "${LOGDIR}/steps"
		step_exec -f "${LOGDIR}/fail" -l "$_log" \
			"${EXECDIR}/${STEP}.sh" || _exit="$?"
		_t1="$(date '+%s')"
		step_end -d "$((_t1 - _t0))" -e "$_exit" -l "$_log" -n "$STEP" \
			-s "$S" "${LOGDIR}/steps"
		[ $_exit -ne 0 ] && return 1

		# Reboot in progress?
		pgrep shutdown >/dev/null && return 0

		S=$((S + 1))
	done
}

# build_id directory
#
# Generate a new build directory path.
build_id() {
	local _c _d

	_d="$(date '+%Y-%m-%d')"
	_c="$(find "$1" -type d -name "${_d}*" | wc -l)"
	printf '%s.%d\n' "$_d" "$((_c + 1))"
}

# check_perf
#
# Sanity check performance parameters.
check_perf() {
	case "$(sysctl -n hw.perfpolicy)" in
	auto|high)	return 0;;
	esac

	[ "$(sysctl -n hw.setperf)" -eq 100 ] && return 0

	info "non-optimal performance detected, check hw.perfpolicy and hw.setperf"
	return 1
}

# lock_acquire build-dir log-dir
#
# Acquire the mutex lock.
lock_acquire() {
	local _owner
	local _builddir="$1"; : "${_builddir:?}"
	local _logdir="$2"; : "${_logdir:?}"

	_owner="$(cat "${_builddir}/.running" 2>/dev/null || :)"
	if [ -n "$_owner" ]; then
		info "${_owner}: lock already acquired"
		return 1
	fi

	echo "$_logdir" >"${_builddir}/.running"
}

# lock_release build-dir
#
# Release the mutex lock.
lock_release() {
	local _builddir="$1"; : "${_builddir:?}"

	rm -f "${_builddir}/.running"
}

# must_report step-name
#
# Exits 0 if a report must be generated.
must_report() {
	case "$1" in
	end)	return 0;;
	*)	return 1;;
	esac
}

# step_begin -l log -n name -s step-name
#
# Mark the given step as about to execute by writing an entry to the given
# file. The same entry will be overwritten once the step has ended.
step_begin() {
	local _l _n _s

	while [ $# -gt 0 ]; do
		case "$1" in
		-l)	shift; _l="$1";;
		-n)	shift; _n="$1";;
		-s)	shift; _s="$1";;
		*)	break;;
		esac
		shift
	done

	step_end -d -1 -e 0 -l "$_l" -n "$_n" -s "$_s" "$1"
}

# step_end [-e exit] [-l log] -d duration -n name -s step-name file
#
# Mark the given step as ended by writing an entry to the given file.
step_end() {
	local _e=0 _l=""
	local _d _n _s

	while [ $# -gt 0 ]; do
		case "$1" in
		-d)	shift; _d="$1";;
		-e)	shift; _e="$1";;
		-l)	shift; _l="$1";;
		-n)	shift; _n="$1";;
		-s)	shift; _s="$1";;
		*)	break;;
		esac
		shift
	done

	# Remove any existing entry for the same step, could be present if a
	# previous execution failed.
	[ -e "$1" ] && sed -i -e "/step=\"${_s}\"/d" "$1"

	# Caution: all values must be quoted and cannot contain spaces.
	{
		printf 'step="%d"\n' "$_s"
		printf 'name="%s"\n' "$_n"
		printf 'exit="%d"\n' "$_e"
		printf 'duration="%d"\n' "$_d"
		printf 'log="%s"\n' "$_l"
		printf 'user="%s"\n' "$(logname)"
		printf 'time="%d"\n' "$(date '+%s')"
	} | paste -s -d ' ' - >>"$1"
}

# step_exec -f fail -l log step
#
# Execute the given step and redirect any output to log.
step_exec() (
	local _fail _log _step

	while [ $# -gt 0 ]; do
		case "$1" in
		-f)	shift; _fail="$1";;
		-l)	shift; _log="$1";;
		*)	break;;
		esac
		shift
	done
	_step="$1"
	: "${_fail:?}"
	: "${_log:?}"
	: "${_step:?}"

	[ -t 0 ] || exec >/dev/null 2>&1

	trap ': >$_fail' INT

	{ sh -eux "$_step" </dev/null 2>&1 || : >"$_fail"; } | tee "$_log"
	if [ -e "$_fail" ]; then
		rm -f "$_fail"
		return 1
	fi
	return 0
)

# step_names
#
# Writes the names of all steps in execution order.
# The last step named end is a sentinel step without a corresponding step
# script.
step_names() {
	cat <<-EOF
	env
	cvs
	patch
	kernel
	env
	base
	release
	checkflist
	xbase
	xrelease
	image
	revert
	distrib
	end
	EOF
}

# step_resolve step-id
#
# Resolve the given numeric step to its corresponding name.
step_resolve() {
	local _step

	_step="$(step_names | sed -n -e "${1}p")"
	if [ -n "$_step" ]; then
		echo "$_step"
	else
		return 1
	fi
}

. "${EXECDIR:-/usr/local/libexec/robsd}/util.sh"

setprogname "robsd"
config_load

# Ignore sticky diff(s) if not present.
if [ -n "$SRCDIFF" ] && ! [ -e "$SRCDIFF" ]; then
	SRCDIFF=""
fi
if [ -n "$XDIFF" ] && ! [ -e "$XDIFF" ]; then
	XDIFF=""
fi

COMMENT=""
DETACH=0
LOGDIR=""
S=1
STEP=""

while getopts "DS:X:c:r:" opt; do
	case "$opt" in
	D)	DETACH=1;;
	S)
		if [ -n "$SRCDIFF" ]; then
			fatal "${SRCDIFF}: src diff already specified"
		fi
		SRCDIFF="$OPTARG"
		;;
	X)
		if [ -n "$XDIFF" ]; then
			fatal "${XDIFF}: xenocara diff already specified"
		fi
		XDIFF="$OPTARG"
		;;
	c)	COMMENT="$OPTARG";;
	r)	LOGDIR="$OPTARG";;
	*)	usage;;
	esac
done
shift $((OPTIND - 1))
[ $# -ne 0 ] && usage

trap 'atexit' EXIT
trap 'info "caught SIGINT"' INT

if [ "$DETACH" -eq 1 ]; then
	exec </dev/null >"${LOGDIR}/robsd.log" 2>&1
fi

if [ -z "$LOGDIR" ]; then
	check_perf || exit 1

	LOGDIR="${BUILDDIR}/$(build_id "$BUILDDIR")"
	mkdir "$LOGDIR"
else
	S="$(step_next "${LOGDIR}/steps")"
	info "resume build from step ${S}"
fi
info "using directory ${LOGDIR}"

# Redundant export since it's already done by config_load but
# silence shellcheck.
RELEASEDIR="$(release_dir "$LOGDIR")"; export RELEASEDIR

if ! lock_acquire "$BUILDDIR" "$LOGDIR"; then
	# Do not leave an empty release around.
	[ "$S" -eq 1 ] && rm -r "$LOGDIR"

	fatal "already running"
fi

SRCDIFF="$(diff_copy "$SRCDIFF" "${LOGDIR}/src.diff")" ||
	fatal "src diff already specified"
XDIFF="$(diff_copy "$XDIFF" "${LOGDIR}/xenocara.diff")" ||
	fatal "xenocara diff already specified"

if [ -n "$COMMENT" ]; then
	if ! comment "$COMMENT" "${LOGDIR}/comment"; then
		fatal "comment already specified"
	fi
fi

if [ "$KEEP" -gt 0 ]; then
	/usr/local/sbin/robsd-clean "$KEEP"
fi

if [ "$DETACH" -eq 1 ]; then
	# Reinstall trap handler since they are not inherited by subprocesses.
	trap '-' EXIT
	{ trap 'atexit' EXIT; main; } &
else
	main
fi
