#!/bin/sh

set -eu

usage() {
	cat <<-EOF | xargs 1>&2
	usage: release
	[-v]
	[-d diff]
	[-k keep]
	[-r path]
	EOF
	exit 1
}

fatal() {
	info "$@"
	exit 1
}

info() {
	echo "release: ${@}" 1>&2
}

atexit() {
	local _err=$?

	lock_release "$LOGDIR"

	if [ $_err -ne 0 ] || must_report "$STAGE"; then
		report -r "${LOGDIR}/report" -s "${LOGDIR}/stages"
	fi

	if [ $_err -ne 0 ]; then
		info "failed in stage ${STAGE:-unknown}"
	fi

	return "$_err"
}

# build_id directory
#
# Generate a new build directory path.
build_id() {
	local _c _d _p

	_d="$(date '+%Y-%m-%d')"
	_c="$(find "$1" -type d -name "${_d}*" | wc -l)"
	printf '%s.%d\n' "$_d" "$((_c + 1))"
}

# check_perf
#
# Sanity check performance parameters.
check_perf() {
	case "$(sysctl -n hw.perfpolicy)" in
	auto|high)	return 0;;
	esac

	[ "$(sysctl -n hw.setperf)" -eq 100 ] && return 0

	info "non-optimal performance detected, check hw.perfpolicy and hw.setperf"
	return 1
}

# lock_present directory
#
# Exits 0 if no build lock already is acquired.
lock_present() {
	! ls $1/*/running 2>/dev/null | cmp -s - /dev/null
}

# lock_acquire directory
#
# Acquire a new build lock.
lock_acquire() {
	>"${1}/running"
}

# lock_release directory
#
# Release the current build lock.
lock_release() {
	rm -f "${1}/running"
}

# log_id stage-id stage-name
#
# Generate the corresponding log file name for the given stage.
log_id() {
	printf '%02d-%s.log' "$1" "$2"
}

# must_reboot stage
#
# Exits 0 if a reboot is required before executing the next stage.
must_reboot() {
	case "$1" in
	kernel)
		cat <<-EOF >>/etc/rc.firsttime
		exec </dev/null >/dev/null 2>&1
		/usr/local/sbin/release -r ${LOGDIR} &
		EOF
		return 0
		;;
	*)	return 1;;
	esac
}

# must_report stage
#
# Exits 0 if a report must be generated.
must_report() {
	case "$1" in
	end)	return 0;;
	*)	return 1;;
	esac
}

# prev_release
#
# Get the previous release directory.
prev_release() {
	find "$BUILDDIR" -type d -mindepth 1 -maxdepth 1 |
	sort -n |
	grep -B 1 -e "$LOGDIR" |
	head -1
}

# purge dir count
#
# Keep the latest count number of directories in dir.
purge() {
	local _dir="$1" _n="$2" _d

	find "$_dir" -type d -mindepth 1 -maxdepth 1 |
	sort -n |
	tail -r |
	tail -n "+$((_n + 1))" |
	while read _d; do
		info "removing directory ${_d}"
		rm -r "$_d"
	done
}

# report -r report -s stages
#
# Generate a build report and save it to report.
report() {
	local _i=1 _name='' _tot=0 _exit=0 _line _report _stages _status

	while [ $# -gt 0 ]; do
		case "$1" in
		-r)	shift; _report="$1";;
		-s)	shift; _stages="$1";;
		*)	break;;
		esac
		shift
	done

	[ -e "$_stages" ] || return 0

	while stage_eval "$_i" "$_stages"; do
		[ $_i -gt 1 ] && echo

		_name="${_STAGE[$(stage_field name)]}"
		_exit="${_STAGE[$(stage_field exit)]}"
		_tot=$((_tot + ${_STAGE[$(stage_field duration)]}))

		printf '> %s:\n' "$_name"
		printf 'Exit: %d\n' "$_exit"
		printf 'Duration: %s\n' \
                        "$(report_duration "${_STAGE[$(stage_field duration)]}")"
                printf 'Log: %s\n' "$(basename "${_STAGE[$(stage_field log)]}")"
                report_log "$_name" "${_STAGE[$(stage_field log)]}"

		_i=$((_i + 1))
	done >"$_report"

	if [ "$_exit" -eq 0 ]; then
		_status='ok'
	else
		_status="failed in ${_name}"
	fi

	# Add stats section to the beginning of the report.
	ed -s <<-EOF "$_report"
	H
	0a
	> stats:
	Build: ${LOGDIR}
	Status: ${_status}
	Duration: $(report_duration "$_tot")
	Size: $(report_size "${RELEASEDIR}/bsd")
	Size: $(report_size "${RELEASEDIR}/bsd.mp")
	Size: $(report_size "${RELEASEDIR}/bsd.rd")

	.
	w
	EOF

	# Do not send mail during interactive invocations.
	[ -t 0 ] && return 0

	mail -s "release: ${_status}" \
		$(report_recipients "$_stages") <"$_report"
}

# report_duration duration
#
# Writes a human readable representation of the given duration.
report_duration() {
	local _d="$1" _h= _m= _s=

	[ $_d -eq 0 ] && { echo 0; return 0; }

	if [ $_d -gt 3600 ]; then
		_h="$((_d / 3600))h"
		_d=$((_d % 3600))
	fi

	if [ $_d -gt 60 ]; then
		_m="$((_d / 60))m"
		_d=$((_d % 60))
	fi

	if [ $_d -gt 0 ]; then
		_s="${_d}s"
	fi

	echo $_h $_m $_s
}

# report_log stage log
#
# Writes an excerpt of the given log.
report_log() {
	[ -s "$2" ] && echo

	case "$1" in
	env|cvs|patch|revert|distrib)
		cat "$2"
		;;
	checkflist)
		# Silent if the log only contains PS4 traces.
		grep -vq '^\+' "$2" || return 0
		cat "$2"
		;;
	*)
		tail "$2"
		;;
	esac
}

# report_size file
#
# Writes a human readable representation of the size of the given file.
# If the same file is present in the previous release, report that size as well.
report_size() {
	local _f="$1" _name _prev

	_name="$(basename "$_f")"

	printf '%s' "$_name"
	if ! [ -e "$_f" ]; then
		printf ' 0\n'
		return 0
	fi

	printf ' %s' "$(du -h "$_f" | awk '{print $1}')"

	_prev="$(prev_release)"
	if [ -n "$_prev" ]; then
		printf ' (%s)' "$(du -h "$(release_dir "$_prev")/${_name}" | awk '{print $1}')"
	fi

	printf '\n'
}

# stage_end -d duration -e exit -l log -n name -s stage file
#
# Mark the given stage as ended by writing an entry to the given file.
stage_end() {
	local _d _e _l _n _s

	while [ $# -gt 0 ]; do
		case "$1" in
		-d)	shift; _d="$1";;
		-e)	shift; _e="$1";;
		-l)	shift; _l="$1";;
		-n)	shift; _n="$1";;
		-s)	shift; _s="$1";;
		*)	break;;
		esac
		shift
	done

        # Remove any existing entry for the same stage, could be present if a
        # previous execution failed.
	[ -e "$1" ] && sed -i -e "/stage=\"${_s}\"/d" "$1"

        # Caution: all values must be quoted and cannot contain spaces.
	{
		printf 'stage="%d" ' "$_s"
		printf 'name="%s" ' "$_n"
		printf 'exit="%d" ' "$_e"
		printf 'duration="%d" ' "$_d"
		printf 'log="%s" ' "$_l"
		printf 'user="%s" ' "$(logname)"
		printf 'time="%d"' "$(date '+%s')"
		printf '\n'
	} >>"$1"
}

# stage_exec -f fail -l log stage
#
# Execute the given stage and redirect any output to log.
stage_exec() (
	local _fail _log

	while [ $# -gt 0 ]; do
		case "$1" in
		-f)	shift; _fail="$1";;
		-l)	shift; _log="$1";;
		*)	break;;
		esac
		shift
	done

	[ -t 0 ] || exec >/dev/null 2>&1

	trap ">$_fail" INT

	{ sh -eux "$1" </dev/null 2>&1 || >"$_fail"; } | tee "$_log"
	if [ -e "$_fail" ]; then
		rm -f "$_fail"
		return 1
	fi
	return 0
)

# stage_names
#
# Writes the names of all stages in execution order.
# The last stage named end is a sentinel stage without a corresponding stage
# script.
stage_names() {
	cat <<-EOF
	env
	cvs
	patch
	kernel
	env
	base
	release
	checkflist
	xbase
	xrelease
	image
	revert
	distrib
	end
	EOF
}

# stage_next file
#
# Outputs the next stage to execute. If the last stage failed, it will be
# executed again.
stage_next() {
	stage_eval -1 "$1"
	if [ ${_STAGE[$(stage_field exit)]} -ne 0 ]; then
		echo "${_STAGE[$(stage_field stage)]}"
	else
		echo "$((${_STAGE[$(stage_field stage)]} + 1))"
	fi
}

# stage_resolve stage
#
# Resolve the given numeric stage to its corresponding name.
stage_resolve() {
	local _stage="$(stage_names | sed -n -e "${1}p")"

	if [ -n "$_stage" ]; then
		echo "$_stage"
	else
		return 1
	fi
}

[ $(id -u) -ne 0 ] && fatal "must be run as root"

# Global variables with sensible defaults.
export BSDOBJDIR; BSDOBJDIR="/usr/obj"
export BSDSRCDIR; BSDSRCDIR="/usr/src"
export BUILDDIR
export CVSROOT
export CVSUSER
export DESTDIR
export DIFF; DIFF=""
export EXECDIR; EXECDIR="/usr/local/libexec/release"
export LOGDIR
export MAKEFLAGS; MAKEFLAGS="-j$(sysctl -n hw.ncpuonline)"
export PATH; PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/X11R6/bin"
export RELEASEDIR
export SIGNIFY; SIGNIFY=""
export SSHHOST
export SSHPATH
export SSHUSER
export X11OBJDIR; X11OBJDIR="/usr/xobj"
export X11SRCDIR; X11SRCDIR="/usr/xenocara"

[ -e /root/.releaserc ] && . /root/.releaserc

# Ensure mandatory variables are defined.
: "${BUILDDIR:?}"
: "${CVSROOT:?}"
: "${CVSUSER:?}"
: "${DESTDIR:?}"
: "${SSHHOST:?}"
: "${SSHPATH:?}"
: "${SSHUSER:?}"
: "${X11OBJDIR:?}"

. "${EXECDIR}/util.sh"

KEEP=0
LOGDIR=""
S=1
STAGE=""

while getopts "d:k:r:v" opt; do
	case "$opt" in
	d)	DIFF="$OPTARG";;
	k)	KEEP="$OPTARG";;
	r)	LOGDIR="$OPTARG";;
	v)	set -x;;
	*)	usage;;
	esac
done
shift $((OPTIND - 1))
[ $# -ne 0 ] && usage

trap 'atexit' EXIT
trap 'info "caught SIGINT"' INT

if [ -z "$LOGDIR" ]; then
	check_perf || exit 1

	LOGDIR="${BUILDDIR}/$(build_id "$BUILDDIR")"
	mkdir "$LOGDIR"
else
	S="$(stage_next "${LOGDIR}/stages")"
	info "resume build from stage ${S}"
fi
info "using directory ${LOGDIR}"
RELEASEDIR="$(release_dir "$LOGDIR")"

if lock_present "$BUILDDIR"; then
	# Do not leave an empty release around.
	[ $STAGE -eq 1 ] && rm -r "$LOGDIR"

	fatal "already running"
fi
lock_acquire "$LOGDIR"

if [ -e "${LOGDIR}/src.diff" ]; then
	if [ -n "$DIFF" ]; then
		fatal "diff already specified"
	fi
	DIFF="${LOGDIR}/src.diff"
fi

if [ "$KEEP" -gt 0 ]; then
	purge "$BUILDDIR" "$KEEP"
fi

while :; do
	STAGE="$(stage_resolve "$S")"
	[ "$STAGE" = "end" ] && exit 0
	info "stage ${STAGE}"

	LOG="${LOGDIR}/$(log_id "$S" "$STAGE")"
	EXIT=0
	T0="$(date '+%s')"
        stage_exec -f "${LOGDIR}/fail" -l "$LOG" "${EXECDIR}/${STAGE}.sh" ||
		EXIT=1
	T1="$(date '+%s')"
	stage_end -d "$((T1 - T0))" -e "$EXIT" -l "$LOG" -n "$STAGE" -s "$S" \
		"${LOGDIR}/stages"
	[ $EXIT -ne 0 ] && exit 1

        # Add some grace before rebooting in order to let the script finish.
	must_reboot "$STAGE" && { shutdown -r '+1'; exit 0; }

	S=$((S + 1))
done
