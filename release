#!/bin/sh

set -eu

usage() {
	cat <<-EOF | xargs 1>&2
	usage: release
	[-v]
	[-d diff]
	[-k keep]
	[-r path]
	EOF
	exit 1
}

fatal() {
	info "$@"
	exit 1
}

info() {
	echo "release: ${@}" 1>&2
}

atexit() {
	local _err=$?

	lock_release "$LOGDIR"

	if [ $_err -ne 0 ] || must_report "$STAGE"; then
		report -e "$_err" -r "${LOGDIR}/report" -s "${LOGDIR}/stages"
	fi

	if [ $_err -ne 0 ]; then
		info "failed in stage ${STAGE:-unknown} (${S})"
	fi

	return "$_err"
}

# build_id directory
#
# Generate a new build directory path.
build_id() {
	local _c _d _p

	_d="$(date '+%Y-%m-%d')"
	_c="$(find "$1" -type d -name "${_d}*" | wc -l)"
	printf '%s.%d\n' "$_d" "$((_c + 1))"
}

# check_perf
#
# Sanity check performance parameters.
check_perf() {
	case "$(sysctl -n hw.perfpolicy)" in
	auto|high)	return 0;;
	esac

	[ "$(sysctl -n hw.setperf)" -eq 100 ] && return 0

	info "non-optimal performance detected, check hw.perfpolicy and hw.setperf"
	return 1
}

# end_stage -d duration -e exit -l log -n name -s stage file
#
# Mark the given stage as ended by writing an entry to the given file.
end_stage() {
	local _d _e _l _n _s

	while [ $# -gt 0 ]; do
		case "$1" in
		-d)	shift; _d="$1";;
		-e)	shift; _e="$1";;
		-l)	shift; _l="$1";;
		-n)	shift; _n="$1";;
		-s)	shift; _s="$1";;
		*)	break;;
		esac
		shift
	done

        # Remove any existing entry for the same stage, could be present if a
        # previous execution failed.
	[ -e "$1" ] && sed -i -e "/stage=\"${_s}\"/d" "$1"

	printf 'stage="%d" name="%s" exit="%d" duration="%d" log="%s" time="%d"\n' \
		"$_s" "$_n" "$_e" "$_d" "$_l" "$(date '+%s')" >>"$1"
}

# eval_stage stage file
#
# Read the given stage from file and as a side-effect assign all variables tied
# to it.
eval_stage() {
	local _stage="$1" _file="$2" _line

	if [ $_stage -lt 0 ]; then
		_line="$(tail "$_stage" "$_file" | head -1)"
	else
		_line="$(sed -n -e "${_stage}p" "$_file")"
	fi
	[ -z "$_line" ] && return 1

	eval "$_line"
}

# exec_stage -f fail -l log stage
#
# Execute the given stage and redirect any output to log.
exec_stage() (
	local _fail _log

	while [ $# -gt 0 ]; do
		case "$1" in
		-f)	shift; _fail="$1";;
		-l)	shift; _log="$1";;
		*)	break;;
		esac
		shift
	done

	[ -t 0 ] || exec >/dev/null 2>&1

	trap ">$_fail" INT

	{ sh -eux "$1" </dev/null 2>&1 || >"$_fail"; } | tee "$_log"
	if [ -e "$_fail" ]; then
		rm -f "$_fail"
		return 1
	fi
	return 0
)

# lock_present directory
#
# Exits 0 if no build lock already is acquired.
lock_present() {
	! ls $1/*/running 2>/dev/null | cmp -s - /dev/null
}

# lock_acquire directory
#
# Acquire a new build lock.
lock_acquire() {
	>"${1}/running"
}

# lock_release directory
#
# Release the current build lock.
lock_release() {
	rm -f "${1}/running"
}

# next_stage file
#
# Outputs the next stage to execute. If the last stage failed, it will be
# executed again.
next_stage() {
	eval_stage -1 "$1"
	if [ $exit -ne 0 ]; then
		echo "$stage"
	else
		echo "$((stage + 1))"
	fi
}

# log_id stage-id stage-name
#
# Generate the corresponding log file name for the given stage.
log_id() {
	printf '%02d-%s.log' "$1" "$2"
}

# must_reboot stage
#
# Exits 0 if a reboot is required before executing the next stage.
must_reboot() {
	case "$1" in
	kernel)
		cat <<-EOF >>/etc/rc.firsttime
		exec </dev/null >/dev/null 2>&1
		/usr/local/sbin/release -r ${LOGDIR} &
		EOF
		return 0
		;;
	*)	return 1;;
	esac
}

# must_report stage
#
# Exits 0 if a report must be generated.
must_report() {
	case "$1" in
	end)	return 0;;
	*)	return 1;;
	esac
}

# purge dir count
#
# Keep the latest count number of directories in dir.
purge() {
	local _dir="$1" _n="$2" _d

	find "$_dir" -type d -mindepth 1 -maxdepth 1 |
	sort -n |
	tail -r |
	tail -n "+$((_n + 1))" |
	while read _d; do
		info "removing directory ${_d}"
		rm -r "$_d"
	done
}

# report -e exit -r report -s stages
#
# Generate a build report and save it to report.
report() {
	local _i=1 _tot=0 _exit _line _report _stages _subject

	while [ $# -gt 0 ]; do
		case "$1" in
		-e)	shift; _exit="$1";;
		-r)	shift; _report="$1";;
		-s)	shift; _stages="$1";;
		*)	break;;
		esac
		shift
	done

	[ -e "$_stages" ] || return 0

	while eval_stage "$_i" "$_stages"; do
		[ $_i -gt 1 ] && echo

		_tot=$((_tot + duration))

		printf '> %s:\n' "$name"
		printf 'Exit: %d\n' "$exit"
		printf 'Duration: %s\n' "$(report_duration "$duration")"
		printf 'Log: %s\n' "$(basename "$log")"
		report_log "$name" "$log"

		_i=$((_i + 1))
	done >"$_report"

	# Add stats section to the beginning of the report.
	ed -s <<-EOF "$_report"
	H
	0a
	> stats:
	Build: ${LOGDIR}
	Duration: $(report_duration "$_tot")
	Size: $(report_size "${RELEASEDIR}/bsd")
	Size: $(report_size "${RELEASEDIR}/bsd.mp")
	Size: $(report_size "${RELEASEDIR}/bsd.rd")

	.
	w
	EOF

	# Do not send mail during interactive invocations.
	[ -t 0 ] && return 0

	_subject="$([ "$_exit" -eq 0 ] && echo 'success' || echo 'failure')"
	mail -s "release build: ${_subject}" "${USER:-root}" <"$_report"
}

# report_duration duration
#
# Writes a human readable representation of the given duration.
report_duration() {
	local _d="$1" _h= _m= _s=

	[ $_d -eq 0 ] && { echo 0; return 0; }

	if [ $_d -gt 3600 ]; then
		_h="$((_d / 3600))h"
		_d=$((_d % 3600))
	fi

	if [ $_d -gt 60 ]; then
		_m="$((_d / 60))m"
		_d=$((_d % 60))
	fi

	if [ $_d -gt 0 ]; then
		_s="${_d}s"
	fi

	echo $_h $_m $_s
}

# report_log stage log
#
# Writes an excerpt of the given log.
report_log() {
	[ -s "$2" ] && echo

	case "$1" in
	start|cvs|patch|revert|distrib)
		cat "$2"
		;;
	*)
		tail "$2"
		;;
	esac
}

# report_size file
#
# Writes a human readable representation of the size of the given file.
report_size() {
	local _f="$1"

	printf '%s' "$(basename "$_f")"

	if ! [ -e "$_f" ]; then
		printf ' 0\n'
		return 0
	fi

	printf ' %s' "$(du -h "$_f" | awk '{print $1}')"
	printf ' (%d)' "$(size "$_f" | sed -n -e '2p' | awk '{print $4}')"
	printf '\n'
}

[ $(id -u) -ne 0 ] && fatal "must be run as root"

# Global variables with sensible defaults.
export BSDOBJDIR; BSDOBJDIR="/usr/obj"
export BSDSRCDIR; BSDSRCDIR="/usr/src"
export BUILDDIR
export CVSROOT
export CVSUSER
export DESTDIR
export DIFF; DIFF=""
export EXECDIR; EXECDIR="/usr/local/libexec/release"
export LOGDIR
export MAKEFLAGS; MAKEFLAGS="-j$(sysctl -n hw.ncpuonline)"
export PATH; PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/X11R6/bin"
export RELEASEDIR
export SSHHOST
export SSHPATH
export SSHUSER
export X11OBJDIR; X11OBJDIR="/usr/xobj"
export X11SRCDIR; X11SRCDIR="/usr/xenocara"

[ -e /root/.releaserc ] && . /root/.releaserc

# Ensure mandatory variables are defined.
: "${BUILDDIR:?}"
: "${CVSROOT:?}"
: "${CVSUSER:?}"
: "${DESTDIR:?}"
: "${SSHHOST:?}"
: "${SSHPATH:?}"
: "${SSHUSER:?}"
: "${X11OBJDIR:?}"

KEEP=0
LOGDIR=""
S=1
STAGE=""

while getopts "d:k:r:v" opt; do
	case "$opt" in
	d)	DIFF="$OPTARG";;
	k)	KEEP="$OPTARG";;
	r)	LOGDIR="$OPTARG";;
	v)	set -x;;
	*)	usage;;
	esac
done
shift $((OPTIND - 1))
[ $# -ne 0 ] && usage

trap 'atexit' EXIT

if [ -z "$LOGDIR" ]; then
	check_perf || exit 1

	LOGDIR="${BUILDDIR}/$(build_id "$BUILDDIR")"
	mkdir "$LOGDIR"
else
	S="$(next_stage "${LOGDIR}/stages")"
	info "resume build from stage ${S}"
fi
info "using directory ${LOGDIR}"
RELEASEDIR="${LOGDIR}/$(machine)"

if lock_present "$BUILDDIR"; then
	fatal "already running"
fi
lock_acquire "$LOGDIR"

if [ -e "${LOGDIR}/src.diff" ]; then
	if [ -n "$DIFF" ]; then
		fatal "diff already specified"
	fi
	DIFF="${LOGDIR}/src.diff"
fi

if [ "$KEEP" -gt 0 ]; then
	purge "$BUILDDIR" "$KEEP"
fi

while :; do
	case "$S" in
	1)	STAGE="start";;
	2)	STAGE="cvs";;
	3)	STAGE="patch";;
	4)	STAGE="kernel";;
	5)	STAGE="base";;
	6)	STAGE="release";;
	7)	STAGE="xbase";;
	8)	STAGE="xrelease";;
	9)	STAGE="image";;
	10)	STAGE="revert";;
	11)	STAGE="distrib";;
	12)	STAGE="end"
		exit 0
		;;
	*)	exit 1;;
	esac

	info "stage ${STAGE}"

	LOG="${LOGDIR}/$(log_id "$S" "$STAGE")"
	EXIT=0
	T0="$(date '+%s')"
        exec_stage -f "${LOGDIR}/fail" -l "$LOG" "${EXECDIR}/${STAGE}.sh" ||
		EXIT=1
	T1="$(date '+%s')"
	end_stage -d "$((T1 - T0))" -e "$EXIT" -l "$LOG" -n "$STAGE" -s "$S" \
		"${LOGDIR}/stages"
	[ $EXIT -ne 0 ] && exit 1

        # Add some grace before rebooting in order to let the script finish.
	must_reboot "$STAGE" && { shutdown -r '+1'; exit 0; }

	S=$((S + 1))
done
